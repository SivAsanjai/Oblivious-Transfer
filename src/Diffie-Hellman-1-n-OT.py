from cryptography.hazmat.primitives.asymmetric import dh
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.backends import default_backend

# Configuration: Number of options for OT
n = 7  # Can be any positive integer

# Step 1: Generate parameters for DH
parameters = dh.generate_parameters(generator=2, key_size=512, backend=default_backend())

# Step 2: Alice generates her keys
alice_private_key = parameters.generate_private_key()
alice_public_key = alice_private_key.public_key()

# Step 3: Bob chooses his index c from 0 to n-1
c = 2  # Change this to test other indices

# Bob generates his keys accordingly
bob_private_keys = [parameters.generate_private_key() for _ in range(n)]
bob_public_keys = [bob_private_key.public_key() for bob_private_key in bob_private_keys]

# Alice computes shared secrets and derives keys
alice_shared_keys = [alice_private_key.exchange(bob_public_key) for bob_public_key in bob_public_keys]

def derive_key(shared_key):
    if isinstance(shared_key, int):
        shared_key = shared_key.to_bytes((shared_key.bit_length() + 7) // 8, 'big')
    return HKDF(
        algorithm=hashes.SHA256(),
        length=32,
        salt=None,
        info=b'handshake data',
        backend=default_backend()
    ).derive(shared_key)

keys = [derive_key(shared_key) for shared_key in alice_shared_keys]

# Simulate Bob's ability to derive his selected key
bob_derived_key = derive_key(bob_private_keys[c].exchange(alice_public_key))

# Print results
print(f"Bob's choice index: {c}")
print(f"All keys generated by Alice:")
for idx, key in enumerate(keys):
    print(f"Key {idx}: {key.hex()}")

print(f"\nBob's derived key: {bob_derived_key.hex()}")

# Verify if Bob's derived key matches his choice
if bob_derived_key.hex() == keys[c].hex():
    print("\nBob successfully derived the correct key corresponding to his choice.")
else:
    print("\nBob could not derive the correct key, or derived the wrong key.")
